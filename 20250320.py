import matplotlib
import numpy as np
import matplotlib.pyplot as plt
#------------------------------------------------------------------------------
# Exploring Fancy Index
#------------------------------------------------------------------------------
# 데이터 사이언스에서의 Fancy Indexing은 그렇게 많이 사용하진 않음.
# ML에서는 잘 다룰 수 있어야함.
# ex. arr[0], arr[:5], arr[arr>0]

# rand = np.random.RandomState(42)
# x = rand.randint(100, size=10)
# print(x)

# [51 92 14 71 60 20 82 86 74 74]

#------------------------------------------------------------------------------

# print([x[3],x[7],x[2]])

# [71, 86, 14]

#------------------------------------------------------------------------------

# ind = [3,7,4]
# print(x[ind])

# [71 86 60]

#------------------------------------------------------------------------------

# Indexing 결과 값에 대한 데이터 타입은 전달된 Index의 데이터 타입을 따른다.
# 사실 이것보단 reshape를 많이 쓰긴 함.
# 익숙하기만 하다면 reshape보다 간편하긴 함

# ind = np.array([[3,7],
#                 [4,5]])
# print(x[ind])

# [[71 86]
#  [60 20]]

#------------------------------------------------------------------------------

# X = np.arange(12).reshape((3,4))
# print(X)

# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

#------------------------------------------------------------------------------

# X = np.arange(12).reshape((3,4))
# row = np.array([0,1,2])
# col = np.array([2,1,3])
# print(X[row,col])

# [ 2  5 11]

#------------------------------------------------------------------------------

# print(X[row[:,np.newaxis],col])

# [[ 2  1  3]
#  [ 6  5  7]
#  [10  9 11]]

# print(row[:,np.newaxis]*col)

# [[0 0 0]
#  [2 1 3]
#  [4 2 6]]

#------------------------------------------------------------------------------
# Combined Indexing
#------------------------------------------------------------------------------

# print(X)

# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

#------------------------------------------------------------------------------

# print(X[2,[2,0,1]])
# 2번째 열의 0 번째에서 원소 하나씩 2개를 반환하겠다~
# [10  8  9]

#------------------------------------------------------------------------------

# print(X[1:, [2, 0, 1]])

# [[ 6  4  5]
#  [10  8  9]]

#------------------------------------------------------------------------------

# x = np.arange(10)
# i = np.array([2, 1, 8, 4])
# x[i] = 99
# print(x)

# [ 0 99 99  3 99  5  6  7 99  9]

# x[i]-=10
# print(x)

# [ 0 89 89  3 89  5  6  7 89  9]

#------------------------------------------------------------------------------
# 조심해야할 상황
#------------------------------------------------------------------------------

# x = np.zeros(10)
# x[[0,0]]=[4,6]
# # 0번 위치에 4를 저장하고, 0번 위치에 6을 저장하라는 뜻인데 말이 안됨. 4는 저장이 될리가 없고 6만 저장된다.
# print(x)

# [6. 0. 0. 0. 0. 0. 0. 0. 0. 0.]

# i = [2,3,3,4,4,4]
# x[i]+=1
# print(x)

# [6. 0. 1. 1. 1. 0. 0. 0. 0. 0.]

#------------------------------------------------------------------------------

# x = np.zeros(10)
# np.add.at(x,i,1) # at 차례대로 증가 시켜라
# print(x)

# [0. 0. 1. 2. 3. 0. 0. 0. 0. 0.]

#------------------------------------------------------------------------------

# np.random.seed(42)
# x = np.random.randn(100)
#
# # compute a histogram by hand
# bins = np.linspace(-5, 5, 20)
# counts = np.zeros_like(bins)
#
# # find the appropriate bin for each x
# i = np.searchsorted(bins, x)
#
# # add 1 to each of these bins
# np.add.at(counts, i, 1)
#
# plt.plot(bins,counts,linestyle='steps')

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Sorting Arrays
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------

# selection sort time complexity = O(N^2)
# 원소들 중에 최솟값을 찾아서 맨 앞으로 배치

# def selection_sort(x):
#     for i in range(len(x)):
#         swap = i + np.argmin(x[i:])
#         (x[i],x[swap])=(x[swap],x[i])
#     return x
#
# x = np.array([2,1,4,3,5])

#------------------------------------------------------------------------------
# 해당 교재 저자가 재미로 만들어낸 정렬

# def bogosort(x): # 우연히 만드는 정렬
#     while np.any(x[:-1]>x[1:]):
#         np.random.shuffle(x)
#     return x

#------------------------------------------------------------------------------

# O(N log N) 정렬임. quick sort, merge sort 등이 포함됨
# x = np.array([2,3,1,5,4,9])
# print(np.sort(x))
# print(np.argsort(x))

#------------------------------------------------------------------------------
# 여러 컬럼 정렬하기
#------------------------------------------------------------------------------

rand = np.random.RandomState(42)
# X = rand.randint(0,10,(4,6))
# print(np.sort(X,axis=0))
# print(np.sort(X,axis=1))

#------------------------------------------------------------------------------
# 파티션을 나눠서 정렬

# print(np.partition(x,3))
# print(np.partition(X, 2, axis=1))

#------------------------------------------------------------------------------
# K-NN (K 최근접 이웃) 유클리드 경로를 사용함
#------------------------------------------------------------------------------

# X = rand.rand(10,2)
# print(X)
#
# import seaborn; seaborn.set()
# plt.scatter(X[:,0], X[:,1],s=100);

#------------------------------------------------------------------------------

